{"version":3,"file":"Story-9a6f2b2b.js","sources":["../../ui/blocks/src/blocks/useStory.ts","../../ui/blocks/src/blocks/Story.tsx"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport type { StoryId, Renderer, PreparedStory } from '@storybook/types';\n\nimport type { DocsContextProps } from './DocsContext';\n\nexport function useStory<TRenderer extends Renderer = Renderer>(\n  storyId: StoryId,\n  context: DocsContextProps<TRenderer>\n): PreparedStory<TRenderer> | void {\n  const stories = useStories([storyId], context);\n  return stories && stories[0];\n}\n\nexport function useStories<TRenderer extends Renderer = Renderer>(\n  storyIds: StoryId[],\n  context: DocsContextProps<TRenderer>\n): (PreparedStory<TRenderer> | void)[] {\n  // Legacy docs pages can reference any story by id. Those stories will need to be\n  // asyncronously loaded; we use the state for this\n  const [storiesById, setStories] = useState<Record<StoryId, PreparedStory<TRenderer>>>({});\n\n  useEffect(() => {\n    // deepscan-disable-next-line NO_EFFECT_CALL\n    Promise.all(\n      storyIds.map(async (storyId) => {\n        // loadStory will be called every single time useStory is called\n        // because useEffect does not use storyIds as an input. This is because\n        // HMR can change the story even when the storyId hasn't changed. However, it\n        // will be a no-op once the story has loaded. Furthermore, the `story` will\n        // have an exact equality when the story hasn't changed, so it won't trigger\n        // any unnecessary re-renders\n        const story = await context.loadStory(storyId);\n        setStories((current) =>\n          current[storyId] === story ? current : { ...current, [storyId]: story }\n        );\n      })\n    );\n  });\n\n  return storyIds.map((storyId) => {\n    if (storiesById[storyId]) return storiesById[storyId];\n\n    try {\n      // If we are allowed to load this story id synchonously, this will work\n      return context.storyById(storyId);\n    } catch (err) {\n      return null;\n    }\n  });\n}\n","import type { FC, ComponentProps } from 'react';\nimport React, { useContext } from 'react';\nimport type {\n  Renderer,\n  ModuleExport,\n  ModuleExports,\n  PreparedStory,\n  StoryId,\n} from '@storybook/types';\n\nimport { Story as PureStory, StorySkeleton } from '../components';\nimport type { DocsContextProps } from './DocsContext';\nimport { DocsContext } from './DocsContext';\nimport { useStory } from './useStory';\n\ntype PureStoryProps = ComponentProps<typeof PureStory>;\n\n/**\n * Props to reference another story\n */\ntype StoryRefProps = {\n  /**\n   * Pass the export defining a story to render that story\n   *\n   * ```jsx\n   * import { Meta, Story } from '@storybook/blocks';\n   * import * as ButtonStories from './Button.stories';\n   *\n   * <Meta of={ButtonStories} />\n   * <Story of={ButtonStories.Primary} />\n   * ```\n   */\n  of?: ModuleExport;\n  /**\n   * Pass all exports of the CSF file if this MDX file is unattached\n   *\n   * ```jsx\n   * import { Story } from '@storybook/blocks';\n   * import * as ButtonStories from './Button.stories';\n   *\n   * <Story of={ButtonStories.Primary} meta={ButtonStories} />\n   * ```\n   */\n  meta?: ModuleExports;\n};\n\ntype StoryParameters = {\n  /**\n   * Render the story inline or in an iframe\n   */\n  inline?: boolean;\n  /**\n   * When rendering in an iframe (`inline={false}`), set the story height\n   */\n  height?: string;\n  /**\n   * Whether to run the story's play function\n   */\n  autoplay?: boolean;\n  /**\n   * Internal prop to control if a story re-renders on args updates\n   */\n  __forceInitialArgs?: boolean;\n  /**\n   * Internal prop if this story is the primary story\n   */\n  __primary?: boolean;\n};\n\nexport type StoryProps = StoryRefProps & StoryParameters;\n\nexport const getStoryId = (props: StoryProps, context: DocsContextProps): StoryId => {\n  const { of, meta } = props as StoryRefProps;\n  if ('of' in props && of === undefined) {\n    throw new Error('Unexpected `of={undefined}`, did you mistype a CSF file reference?');\n  }\n\n  if (meta) context.referenceMeta(meta, false);\n  const resolved = context.resolveOf(of || 'story', ['story']);\n  return resolved.story.id;\n};\n\nexport const getStoryProps = <TFramework extends Renderer>(\n  props: StoryParameters,\n  story: PreparedStory<TFramework>,\n  context: DocsContextProps<TFramework>\n): PureStoryProps => {\n  const { parameters = {} } = story || {};\n  const { docs = {} } = parameters;\n  const storyParameters = (docs.story || {}) as StoryParameters & { iframeHeight?: string };\n\n  if (docs.disable) {\n    return null;\n  }\n\n  // prefer block props, then story parameters defined by the framework-specific settings\n  // and optionally overridden by users\n\n  const inline = props.inline ?? storyParameters.inline ?? false;\n\n  if (inline) {\n    const height = props.height ?? storyParameters.height;\n    const autoplay = props.autoplay ?? storyParameters.autoplay ?? false;\n    return {\n      story,\n      inline: true,\n      height,\n      autoplay,\n      // eslint-disable-next-line no-underscore-dangle\n      forceInitialArgs: !!props.__forceInitialArgs,\n      // eslint-disable-next-line no-underscore-dangle\n      primary: !!props.__primary,\n      renderStoryToElement: context.renderStoryToElement,\n    };\n  }\n\n  const height = props.height ?? storyParameters.height ?? storyParameters.iframeHeight ?? '100px';\n  return {\n    story,\n    inline: false,\n    height,\n    // eslint-disable-next-line no-underscore-dangle\n    primary: !!props.__primary,\n  };\n};\n\nconst Story: FC<StoryProps> = (props = { __forceInitialArgs: false, __primary: false }) => {\n  const context = useContext(DocsContext);\n  const storyId = getStoryId(props, context);\n  const story = useStory(storyId, context);\n\n  if (!story) {\n    return <StorySkeleton />;\n  }\n\n  const storyProps = getStoryProps(props, story, context);\n  if (!storyProps) {\n    return null;\n  }\n\n  return <PureStory {...storyProps} />;\n};\n\nexport { Story };\n"],"names":["useStory","storyId","context","stories","useStories","storyIds","storiesById","setStories","useState","useEffect","story","current","getStoryId","props","of","meta","getStoryProps","parameters","docs","storyParameters","height","autoplay","Story","useContext","DocsContext","StorySkeleton","storyProps","React","PureStory"],"mappings":"4IAKgB,SAAAA,EACdC,EACAC,EACiC,CACjC,MAAMC,EAAUC,EAAW,CAACH,CAAO,EAAGC,CAAO,EACtC,OAAAC,GAAWA,EAAQ,CAAC,CAC7B,CAEgB,SAAAC,EACdC,EACAH,EACqC,CAGrC,KAAM,CAACI,EAAaC,CAAU,EAAIC,EAAA,SAAoD,CAAE,CAAA,EAExFC,OAAAA,EAAAA,UAAU,IAAM,CAEN,QAAA,IACNJ,EAAS,IAAI,MAAOJ,GAAY,CAO9B,MAAMS,EAAQ,MAAMR,EAAQ,UAAUD,CAAO,EAC7CM,EAAYI,GACVA,EAAQV,CAAO,IAAMS,EAAQC,EAAU,CAAE,GAAGA,EAAS,CAACV,CAAO,EAAGS,CAAM,CAAA,CACxE,CACD,CAAA,CACH,CACD,EAEML,EAAS,IAAKJ,GAAY,CAC/B,GAAIK,EAAYL,CAAO,EAAG,OAAOK,EAAYL,CAAO,EAEhD,GAAA,CAEK,OAAAC,EAAQ,UAAUD,CAAO,OACpB,CACL,OAAA,IACT,CAAA,CACD,CACH,CCsBA,MAAAW,EAAA,CAAAC,EAAAX,IAAA,CACA,KAAA,CAAA,GAAAY,EAAA,KAAAC,CAAA,EAAAF,EACA,GAAA,OAAAA,GAAAC,IAAA,OACA,MAAA,IAAA,MAAA,oEAAA,EAGA,OAAAC,GAAAb,EAAA,cAAAa,EAAA,EAAA,EACAb,EAAA,UAAAY,GAAA,QAAA,CAAA,OAAA,CAAA,EACA,MAAA,EACA,EAEAE,EAAA,CACAH,EACAH,EACAR,IACA,CACA,KAAA,CAAA,WAAAe,EAAA,CAAA,GAAAP,GAAA,CAAA,EACA,CAAA,KAAAQ,EAAA,EAAA,EAAAD,EACAE,EAAAD,EAAA,OAAA,GAEA,GAAAA,EAAA,QACA,OAAA,KAQA,GAFAL,EAAA,QAAAM,EAAA,QAAA,GAEA,CACAC,MAAAA,EAAAP,EAAA,QAAAM,EAAA,OACAE,EAAAR,EAAA,UAAAM,EAAA,UAAA,GACA,MAAA,CACA,MAAAT,EACA,OAAA,GACA,OAAAU,EACA,SAAAC,EAEA,iBAAA,CAAA,CAAAR,EAAA,mBAEA,QAAA,CAAA,CAAAA,EAAA,UACA,qBAAAX,EAAA,oBAAA,CAEA,CAEA,MAAAkB,EAAAP,EAAA,QAAAM,EAAA,QAAAA,EAAA,cAAA,QACA,MAAA,CACA,MAAAT,EACA,OAAA,GACA,OAAAU,EAEA,QAAA,CAAA,CAAAP,EAAA,SAAA,CAEA,EAEAS,EAAA,CAAAT,EAAA,CAAA,mBAAA,GAAA,UAAA,MAAA,CACA,MAAAX,EAAAqB,aAAAC,CAAA,EACAvB,EAAAW,EAAAC,EAAAX,CAAA,EACAQ,EAAAV,EAAAC,EAAAC,CAAA,EAEA,GAAA,CAAAQ,EACA,uBAAAe,EAAA,IAAA,EAGA,MAAAC,EAAAV,EAAAH,EAAAH,EAAAR,CAAA,EACA,OAAAwB,EAIAC,EAAA,cAAAC,EAAA,CAAA,GAAAF,CAAA,CAAA,EAHA,IAIA;;;;;;;;;;;;;;;"}